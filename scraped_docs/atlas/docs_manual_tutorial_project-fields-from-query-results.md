# Project Fields to Return from Query - MongoDB Manual v8.0


Docs Home / MongoDB Manual / CRUD Operations / Query Project Fields to Return from Query On this page Return All Fields in Matching Documents Return the Specified Fields and the _id Field Only Suppress _id Field Return All But the Excluded Fields Return Specific Fields in Embedded Documents Suppress Specific Fields in Embedded Documents Projection on Embedded Documents in an Array Project Specific Array Elements in the Returned Array Project Fields with Aggregation Expressions Project Fields to Return from a Query with MongoDB Atlas Additional Considerations You can query embedded documents in MongoDB by using the following
methods: Your programming language's driver. The MongoDB Atlas UI . To learn more, see Project Fields to Return from a Query with MongoDB Atlas . MongoDB Compass . â¤ Use the Select your language drop-down menu in the
upper-right to set the language of the following examples or select
MongoDB Compass. By default, queries in MongoDB return all fields in matching documents.
To limit the amount of data that MongoDB sends to applications, you can
include a projection document to specify or restrict fields to
return. MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala This page provides examples of query operations with projection using the db.collection.find() method in mongosh . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using MongoDB Compass . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using mongoc_collection_find_with_opts . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the MongoCollection.Find() method in the MongoDB C# Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the Collection.Find function in the MongoDB Go Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the com.mongodb.reactivestreams.client.MongoCollection.find method in the MongoDB Java Reactive Streams Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the com.mongodb.client.MongoCollection.find method in the MongoDB Java Synchronous Driver . Tip The driver provides com.mongodb.client.model.Filters helper methods to facilitate the creation of filter
documents. The examples on this page use these methods to
create the filter documents. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection by using the MongoCollection.find() method in the MongoDB Kotlin Coroutine Driver . Tip The driver provides com.mongodb.client.model.Filters helper methods to facilitate the creation of filter
documents. The examples on this page use these methods to
create the filter documents. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the motor.motor_asyncio.AsyncIOMotorCollection.find method in the Motor driver. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the Collection.find() method in
the MongoDB Node.js Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the MongoDB::Collection::find() method
in the MongoDB Perl Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the MongoDB\\Collection::find() method in the MongoDB PHP Library . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the pymongo.collection.Collection.find method in the PyMongo Python driver. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the Mongo::Collection#find() method in the MongoDB Ruby Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations with projection using the collection.find() method
in the MongoDB Scala Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . insertMany ( [ { item : "journal" , status : "A" , size : { h : 14 , w : 21 , uom : "cm" } , instock : [ { warehouse : "A" , qty : 5 } ] } , { item : "notebook" , status : "A" , size : { h : 8.5 , w : 11 , uom : "in" } , instock : [ { warehouse : "C" , qty : 5 } ] } , { item : "paper" , status : "D" , size : { h : 8.5 , w : 11 , uom : "in" } , instock : [ { warehouse : "A" , qty : 60 } ] } , { item : "planner" , status : "D" , size : { h : 22.85 , w : 30 , uom : "cm" } , instock : [ { warehouse : "A" , qty : 40 } ] } , { item : "postcard" , status : "A" , size : { h : 10 , w : 15.25 , uom : "cm" } , instock : [ { warehouse : "B" , qty : 15 } , { warehouse : "C" , qty : 35 } ] } ]) ; [ { "item" : "journal" , "status" : "A" , "size" : { "h" : 14 , "w" : 21 , "uom" : "cm" } , "instock" : [ { "warehouse" : "A" , "qty" : 5 } ] } , { "item" : "notebook" , "status" : "A" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" } , "instock" : [ { "warehouse" : "C" , "qty" : 5 } ] } , { "item" : "paper" , "status" : "D" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" } , "instock" : [ { "warehouse" : "A" , "qty" : 60 } ] } , { "item" : "planner" , "status" : "D" , "size" : { "h" : 22.85 , "w" : 30 , "uom" : "cm" } , "instock" : [ { "warehouse" : "A" , "qty" : 40 } ] } , { "item" : "postcard" , "status" : "A" , "size" : { "h" : 10 , "w" : 15.25 , "uom" : "cm" } , "instock" : [ { "warehouse" : "B" , "qty" : 15 } , { "warehouse" : "C" , "qty" : 35 } ] } ] For instructions on inserting documents in MongoDB Compass,
see Insert Documents . mongoc_collection_t *collection; mongoc_bulk_operation_t *bulk; bson_t *doc; bool r; bson_error_t error; bson_t reply; collection = mongoc_database_get_collection (db, "inventory" ) ; bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL ) ; doc = BCON_NEW ( "item" , BCON_UTF8 ( "journal" ) , "status" , BCON_UTF8 ( "A" ) , "size" , "{" , "h" , BCON_DOUBLE ( 14 ) , "w" , BCON_DOUBLE ( 21 ) , "uom" , BCON_UTF8 ( "cm" ) , "}" , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 5 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "notebook" ) , "status" , BCON_UTF8 ( "A" ) , "size" , "{" , "h" , BCON_DOUBLE ( 8.5 ) , "w" , BCON_DOUBLE ( 11 ) , "uom" , BCON_UTF8 ( "in" ) , "}" , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "C" ) , "qty" , BCON_INT64 ( 5 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "paper" ) , "status" , BCON_UTF8 ( "D" ) , "size" , "{" , "h" , BCON_DOUBLE ( 8.5 ) , "w" , BCON_DOUBLE ( 11 ) , "uom" , BCON_UTF8 ( "in" ) , "}" , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 60 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "planner" ) , "status" , BCON_UTF8 ( "D" ) , "size" , "{" , "h" , BCON_DOUBLE ( 22.85 ) , "w" , BCON_DOUBLE ( 30 ) , "uom" , BCON_UTF8 ( "cm" ) , "}" , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 40 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "postcard" ) , "status" , BCON_UTF8 ( "A" ) , "size" , "{" , "h" , BCON_DOUBLE ( 10 ) , "w" , BCON_DOUBLE ( 15.25 ) , "uom" , BCON_UTF8 ( "cm" ) , "}" , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "B" ) , "qty" , BCON_INT64 ( 15 ) , "}" , "{" , "warehouse" , BCON_UTF8 ( "C" ) , "qty" , BCON_INT64 ( 35 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } /* "reply" is initialized on success or error */ r = ( bool ) mongoc_bulk_operation_execute (bulk, &reply, &error) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; } var documents = new [] { new BsonDocument { { "item" , "journal" }, { "status" , "A" }, { "size" , new BsonDocument { { "h" , 14 }, { "w" , 21 }, { "uom" , "cm" } } }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 5 } } } } }, new BsonDocument { { "item" , "notebook" }, { "status" , "A" }, { "size" , new BsonDocument { { "h" , 8.5 }, { "w" , 11 }, { "uom" , "in" } } }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "C" }, { "qty" , 5 } } } } }, new BsonDocument { { "item" , "paper" }, { "status" , "D" }, { "size" , new BsonDocument { { "h" , 8.5 }, { "w" , 11 }, { "uom" , "in" } } }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 60 } } } } }, new BsonDocument { { "item" , "planner" }, { "status" , "D" }, { "size" , new BsonDocument { { "h" , 22.85 }, { "w" , 30 }, { "uom" , "cm" } } }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 40 } } } } }, new BsonDocument { { "item" , "postcard" }, { "status" , "A" }, { "size" , new BsonDocument { { "h" , 10 }, { "w" , 15.25 }, { "uom" , "cm" } } }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "B" }, { "qty" , 15 } }, new BsonDocument { { "warehouse" , "C" }, { "qty" , 35 } } } } } }; collection.InsertMany(documents); docs := [] interface {}{ bson.D{ { "item" , "journal" }, { "status" , "A" }, { "size" , bson.D{ { "h" , 14 }, { "w" , 21 }, { "uom" , "cm" }, }}, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 5 }, }, }}, }, bson.D{ { "item" , "notebook" }, { "status" , "A" }, { "size" , bson.D{ { "h" , 8.5 }, { "w" , 11 }, { "uom" , "in" }, }}, { "instock" , bson.A{ bson.D{ { "warehouse" , "EC" }, { "qty" , 5 }, }, }}, }, bson.D{ { "item" , "paper" }, { "status" , "D" }, { "size" , bson.D{ { "h" , 8.5 }, { "w" , 11 }, { "uom" , "in" }, }}, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 60 }, }, }}, }, bson.D{ { "item" , "planner" }, { "status" , "D" }, { "size" , bson.D{ { "h" , 22.85 }, { "w" , 30 }, { "uom" , "cm" }, }}, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 40 }, }, }}, }, bson.D{ { "item" , "postcard" }, { "status" , "A" }, { "size" , bson.D{ { "h" , 10 }, { "w" , 15.25 }, { "uom" , "cm" }, }}, { "instock" , bson.A{ bson.D{ { "warehouse" , "B" }, { "qty" , 15 }, }, bson.D{ { "warehouse" , "EC" }, { "qty" , 35 }, }, }}, }, } result, err := coll.InsertMany(context.TODO(), docs) Publisher<Success> insertManyPublisher = collection.insertMany(asList( Document.parse( "{ item: 'journal', status: 'A', size: { h: 14, w: 21, uom: 'cm' }, instock: [ { warehouse: 'A', qty: 5 }]}" ), Document.parse( "{ item: 'notebook', status: 'A',  size: { h: 8.5, w: 11, uom: 'in' }, instock: [ { warehouse: 'C', qty: 5}]}" ), Document.parse( "{ item: 'paper', status: 'D', size: { h: 8.5, w: 11, uom: 'in' }, instock: [ { warehouse: 'A', qty: 60 }]}" ), Document.parse( "{ item: 'planner', status: 'D', size: { h: 22.85, w: 30, uom: 'cm' }, instock: [ { warehouse: 'A', qty: 40}]}" ), Document.parse( "{ item: 'postcard', status: 'A', size: { h: 10, w: 15.25, uom: 'cm' }, " + "instock: [ { warehouse: 'B', qty: 15 }, { warehouse: 'C', qty: 35 } ] }" ) )); collection.insertMany(asList( Document.parse( "{ item: 'journal', status: 'A', size: { h: 14, w: 21, uom: 'cm' }, instock: [ { warehouse: 'A', qty: 5 }]}" ), Document.parse( "{ item: 'notebook', status: 'A',  size: { h: 8.5, w: 11, uom: 'in' }, instock: [ { warehouse: 'C', qty: 5}]}" ), Document.parse( "{ item: 'paper', status: 'D', size: { h: 8.5, w: 11, uom: 'in' }, instock: [ { warehouse: 'A', qty: 60 }]}" ), Document.parse( "{ item: 'planner', status: 'D', size: { h: 22.85, w: 30, uom: 'cm' }, instock: [ { warehouse: 'A', qty: 40}]}" ), Document.parse( "{ item: 'postcard', status: 'A', size: { h: 10, w: 15.25, uom: 'cm' }, " + "instock: [ { warehouse: 'B', qty: 15 }, { warehouse: 'C', qty: 35 } ] }" ) )); collection.insertMany( listOf( Document( "item" , "journal" ) .append( "status" , "A" ) .append( "size" , Document( "h" , 14 ).append( "w" , 21 ).append( "uom" , "cm" )) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 5 ), )), Document( "item" , "notebook" ) .append( "status" , "A" ) .append( "size" , Document( "h" , 8.5 ).append( "w" , 11 ).append( "uom" , "in" )) .append( "instock" , listOf( Document( "warehouse" , "C" ).append( "qty" , 5 ), )), Document( "item" , "paper" ) .append( "status" , "D" ) .append( "size" , Document( "h" , 8.5 ).append( "w" , 11 ).append( "uom" , "in" )) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 60 ), )), Document( "item" , "planner" ) .append( "status" , "D" ) .append( "size" , Document( "h" , 22.85 ).append( "w" , 30 ).append( "uom" , "cm" )) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 40 ), )), Document( "item" , "postcard" ) .append( "status" , "A" ) .append( "size" , Document( "h" , 10 ).append( "w" , 15.25 ).append( "uom" , "cm" )) .append( "instock" , listOf( Document( "warehouse" , "B" ).append( "qty" , 15 ), Document( "warehouse" , "C" ).append( "qty" , 35 ) )), ) ) await db.inventory.insert_many( [ { "item" : "journal" , "status" : "A" , "size" : { "h" : 14 , "w" : 21 , "uom" : "cm" }, "instock" : [{ "warehouse" : "A" , "qty" : 5 }], }, { "item" : "notebook" , "status" : "A" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" }, "instock" : [{ "warehouse" : "C" , "qty" : 5 }], }, { "item" : "paper" , "status" : "D" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" }, "instock" : [{ "warehouse" : "A" , "qty" : 60 }], }, { "item" : "planner" , "status" : "D" , "size" : { "h" : 22.85 , "w" : 30 , "uom" : "cm" }, "instock" : [{ "warehouse" : "A" , "qty" : 40 }], }, { "item" : "postcard" , "status" : "A" , "size" : { "h" : 10 , "w" : 15.25 , "uom" : "cm" }, "instock" : [{ "warehouse" : "B" , "qty" : 15 }, { "warehouse" : "C" , "qty" : 35 }], }, ] ) await db. collection ( 'inventory' ). insertMany ( [ { item : 'journal' , status : 'A' , size : { h : 14 , w : 21 , uom : 'cm' } , instock : [ { warehouse : 'A' , qty : 5 }] } , { item : 'notebook' , status : 'A' , size : { h : 8.5 , w : 11 , uom : 'in' } , instock : [ { warehouse : 'C' , qty : 5 }] } , { item : 'paper' , status : 'D' , size : { h : 8.5 , w : 11 , uom : 'in' } , instock : [ { warehouse : 'A' , qty : 60 }] } , { item : 'planner' , status : 'D' , size : { h : 22.85 , w : 30 , uom : 'cm' } , instock : [ { warehouse : 'A' , qty : 40 }] } , { item : 'postcard' , status : 'A' , size : { h : 10 , w : 15.25 , uom : 'cm' } , instock : [ { warehouse : 'B' , qty : 15 } , { warehouse : 'C' , qty : 35 } ] } ]) ; $db - > coll ( "inventory" ) - > insert_many ( [ { item   => "journal" , status => "A" , size   => { h => 14 , w => 21 , uom => "cm" } , instock => [ { warehouse => "A" , qty => 5 } ] } , { item   => "notebook" , status => "A" , size   => { h => 8.5 , w => 11 , uom => "in" } , instock => [ { warehouse => "C" , qty => 5 } ] } , { item   => "paper" , status => "D" , size   => { h => 8.5 , w => 11 , uom => "in" } , instock => [ { warehouse => "A" , qty => 60 } ] } , { item   => "planner" , status => "D" , size   => { h => 22.85 , w => 30 , uom => "cm" } , instock => [ { warehouse => "A" , qty => 40 } ] } , { item    => "postcard" , status  => "A" , size    => { h => 10 , w => 15.25 , uom => "cm" } , instock => [ { warehouse => "B" , qty => 15 } , { warehouse => "C" , qty => 35 } ] } ] ) ; $insertManyResult = $db ->inventory-> insertMany ([ [ 'item' => 'journal' , 'status' => 'A' , 'size' => [ 'h' => 14 , 'w' => 21 , 'uom' => 'cm' ], 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 5 ], ], ], [ 'item' => 'notebook' , 'status' => 'A' , 'size' => [ 'h' => 8.5 , 'w' => 11 , 'uom' => 'in' ], 'instock' => [ [ 'warehouse' => 'C' , 'qty' => 5 ], ], ], [ 'item' => 'paper' , 'status' => 'D' , 'size' => [ 'h' => 8.5 , 'w' => 11 , 'uom' => 'in' ], 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 60 ], ], ], [ 'item' => 'planner' , 'status' => 'D' , 'size' => [ 'h' => 22.85 , 'w' => 30 , 'uom' => 'cm' ], 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 40 ], ], ], [ 'item' => 'postcard' , 'status' => 'A' , 'size' => [ 'h' => 10 , 'w' => 15.25 , 'uom' => 'cm' ], 'instock' => [ [ 'warehouse' => 'B' , 'qty' => 15 ], [ 'warehouse' => 'C' , 'qty' => 35 ], ], ], ]) ; db.inventory.insert_many( [ { "item" : "journal" , "status" : "A" , "size" : { "h" : 14 , "w" : 21 , "uom" : "cm" }, "instock" : [{ "warehouse" : "A" , "qty" : 5 }], }, { "item" : "notebook" , "status" : "A" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" }, "instock" : [{ "warehouse" : "C" , "qty" : 5 }], }, { "item" : "paper" , "status" : "D" , "size" : { "h" : 8.5 , "w" : 11 , "uom" : "in" }, "instock" : [{ "warehouse" : "A" , "qty" : 60 }], }, { "item" : "planner" , "status" : "D" , "size" : { "h" : 22.85 , "w" : 30 , "uom" : "cm" }, "instock" : [{ "warehouse" : "A" , "qty" : 40 }], }, { "item" : "postcard" , "status" : "A" , "size" : { "h" : 10 , "w" : 15.25 , "uom" : "cm" }, "instock" : [{ "warehouse" : "B" , "qty" : 15 }, { "warehouse" : "C" , "qty" : 35 }], }, ] ) client [ : inventory ].insert_many ( [ { item: 'journal' , status: 'A' , size: { h: 14 , w: 21 , uom: 'cm' } , instock: [ { warehouse: 'A' , qty: 5 }] } , { item: 'notebook' , status: 'A' , size: { h: 8.5 , w: 11 , uom: 'in' } , instock: [ { warehouse: 'C' , qty: 5 }] } , { item: 'paper' , status: 'D' , size: { h: 8.5 , w: 11 , uom: 'in' } , instock: [ { warehouse: 'A' , qty: 60 }] } , { item: 'planner' , status: 'D' , size: { h: 22.85 , w: 30 , uom: 'cm' } , instock: [ { warehouse: 'A' , qty: 40 }] } , { item: 'postcard' , status: 'A' , size: { h: 10 , w: 15.25 , uom: 'cm' } , instock: [ { warehouse: 'B' , qty: 15 } , { warehouse: 'C' , qty: 35 }] }]) collection.insertMany( Seq ( Document ( """{ item: "journal", status: "A", size: { h: 14, w: 21, uom: "cm" }, instock: [ { warehouse: "A", qty: 5 } ] }""" ), Document ( """{ item: "notebook", status: "A",  size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "C", qty: 5 } ] }""" ), Document ( """{ item: "paper", status: "D", size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "A", qty: 60 } ] }""" ), Document ( """{ item: "planner", status: "D", size: { h: 22.85, w: 30, uom: "cm" }, instock: [ { warehouse: "A", qty: 40 } ] }""" ), Document ( """{ item: "postcard", status: "A", size: { h: 10, w: 15.25, uom: "cm" }, instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }""" ) )).execute() Return All Fields in Matching Documents MongoDB Shell Compass C# Java (Async) Java (Sync) Kotlin (Coroutine) Node.js Perl PHP Python Ruby Scala If you do not specify a projection document, the db.collection.find() method returns all fields in the
matching documents. If you do not specify a projection document, Compass
returns all fields in the matching documents. If you do not specify a projection filter, the MongoCollection.Find() method returns all fields in the matching documents. If you do not specify a projection , the com.mongodb.reactivestreams.client.MongoCollection.find method returns all fields in the matching documents. If you do not specify a projection , the com.mongodb.client.MongoCollection.find method returns all
fields in the matching documents. If you do not specify a projection document, the MongoCollection.find() method returns all
fields in the matching documents. If you do not specify a projection document, the find() method yields all
fields in the matching documents. If you do not specify a projection document, the find() method returns all fields in the matching documents. If you do not specify a projection document, the find() method returns all fields in the matching documents. If you do not specify a projection document, the find method returns
all fields in the matching documents. If you do not specify a projection document, the find() method returns all fields in the matching documents. If you do not specify a projection , the collection.find() method returns all fields in the matching documents. The following example returns all fields from all documents in the inventory collection where the status equals "A" : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } ) Copy the following expression into the Filter field: { status : "A" } Click Find . mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{{ "status" , "A" }}, ) FindPublisher<Document> findPublisher = collection.find(eq( "status" , "A" )); FindIterable<Document> findIterable = collection.find(eq( "status" , "A" )); val findFlow = collection .find(eq( "status" , "A" )) cursor = db.inventory.find({ "status" : "A" }) const cursor = db. collection ( 'inventory' ). find ( { status : 'A' }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } ) ; $cursor = $db ->inventory-> find ([ 'status' => 'A' ]) ; cursor = db.inventory.find({ "status" : "A" }) client [ : inventory ].find ( status: 'A' ) var findObservable = collection.find(equal( "status" , "A" )) The operation corresponds to the following SQL statement: SELECT * from inventory WHERE status = "A" Return the Specified Fields and the _id Field Only A projection can explicitly include several fields by setting the <field> to 1 in the projection document. The following
operation returns all documents that match the query. In the result
set, only the item , status and, by default, the _id fields
return in the matching documents. MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; Be sure to also clean up any open resources by calling the
following methods, as appropriate: bson_destroy mongoc_bulk_operation_destroy mongoc_collection_destroy mongoc_cursor_destroy , var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" )); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" )); val findFlow = collection .find(eq( "status" , "A" )).projection(include( "item" , "status" )) cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 }) client [ : inventory ].find ( { status: 'A' } , projection: { item: 1 , status: 1 }) findObservable = collection.find(equal( "status" , "A" )).projection(include( "item" , "status" )) The operation corresponds to the following SQL statement: SELECT _id, item, status from inventory WHERE status = "A" Suppress _id Field You can remove the _id field from the results by setting it to 0 in the projection, as in the following example: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , _id : 0 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , _id : 0 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "_id" , BCON_INT64 ( 0 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Exclude( "_id" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "_id" , 0 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), excludeId())); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), excludeId())); val findFlow = collection .find(eq( "status" , "A" )).projection(fields(include( "item" , "status" ), excludeId())) cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "_id" : 0 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , _id : 0 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , "_id" = > 0 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , '_id' => 0 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "_id" : 0 }) client [ : inventory ].find ( { status: 'A' } , projection: { item: 1 , status: 1 , _id: 0 }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), excludeId())) The operation corresponds to the following SQL statement: SELECT item, status from inventory WHERE status = "A" Note With the exception of the _id field, you cannot combine inclusion
and exclusion statements in projection documents. Return All But the Excluded Fields Instead of listing the fields to return in the matching document, you
can use a projection to exclude specific fields. The following example
which returns all fields except for the status and the instock fields in the matching documents: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { status : 0 , instock : 0 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { status : 0 , instock : 0 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "status" , BCON_INT64 ( 0 ) , "instock" , BCON_INT64 ( 0 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Exclude( "status" ).Exclude( "instock" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "status" , 0 }, { "instock" , 0 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )).projection(exclude( "item" , "status" )); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )).projection(exclude( "item" , "status" )); val findFlow = collection .find(eq( "status" , "A" )).projection(exclude( "item" , "status" )) cursor = db.inventory.find({ "status" : "A" }, { "status" : 0 , "instock" : 0 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { status : 0 , instock : 0 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { status => 0 , instock => 0 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'status' => 0 , 'instock' => 0 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "status" : 0 , "instock" : 0 }) client [ : inventory ].find ( { status: 'A' } , projection: { status: 0 , instock: 0 }) findObservable = collection.find(equal( "status" , "A" )).projection(exclude( "item" , "status" )) Note With the exception of the _id field, you cannot combine inclusion
and exclusion statements in projection documents. Return Specific Fields in Embedded Documents You can return specific fields in an embedded document. Use the dot notation to refer to the embedded
field and set to 1 in the projection document. The following example returns: The _id field (returned by default), The item field, The status field, The uom field in the size document. The uom field remains embedded in the size document. MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , "size.uom" : 1 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , "size.uom" : 1 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "size.uom" , BCON_INT64 ( 1 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Include( "size.uom" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "size.uom" , 1 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" , "size.uom" )); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" , "size.uom" )); val findFlow = collection .find(eq( "status" , "A" )).projection(include( "item" , "status" , "size.uom" )) cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "size.uom" : 1 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , 'size.uom' : 1 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , "size.uom" = > 1 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'size.uom' => 1 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "size.uom" : 1 }) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'size.uom' = > 1 }) findObservable = collection.find(equal( "status" , "A" )).projection(include( "item" , "status" , "size.uom" )) You can also specify embedded fields using the nested form. For example, { item: 1, status: 1, size: { uom: 1 } } . Suppress Specific Fields in Embedded Documents You can suppress specific fields in an embedded document. Use the dot notation to refer to the embedded
field in the projection document and set to 0 . The following example specifies a projection to exclude the uom field inside the size document. All other fields are returned in
the matching documents: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { "size.uom" : 0 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { "size.uom" : 0 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "size.uom" , BCON_INT64 ( 0 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Exclude( "size.uom" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "size.uom" , 0 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )).projection(exclude( "size.uom" )); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )).projection(exclude( "size.uom" )); val findFlow = collection .find(eq( "status" , "A" )).projection(exclude( "size.uom" )) cursor = db.inventory.find({ "status" : "A" }, { "size.uom" : 0 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { 'size.uom' : 0 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { "size.uom" = > 0 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'size.uom' => 0 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "size.uom" : 0 }) client [ : inventory ].find ( { status: 'A' } , projection: { 'size.uom' = > 0 }) findObservable = collection.find(equal( "status" , "A" )).projection(exclude( "size.uom" )) You can also specify embedded fields using the nested form. For example, { size: { uom: 0 } } . Projection on Embedded Documents in an Array Use dot notation to project specific
fields inside documents embedded in an array. The following example specifies a projection to return: The _id field (returned by default), The item field, The status field, The qty field in the documents embedded in the instock array. MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , "instock.qty" : 1 } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , "instock.qty" : 1 } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock.qty" , BCON_INT64 ( 1 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Include( "instock.qty" ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock.qty" , 1 }, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" , "instock.qty" )); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )).projection(include( "item" , "status" , "instock.qty" )); val findFlow = collection .find(eq( "status" , "A" )).projection(include( "item" , "status" , "instock.qty" )) cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "instock.qty" : 1 }) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , 'instock.qty' : 1 }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , "instock.qty" = > 1 } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock.qty' => 1 ]], ) ; cursor = db.inventory.find({ "status" : "A" }, { "item" : 1 , "status" : 1 , "instock.qty" : 1 }) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock.qty' = > 1 }) findObservable = collection.find(equal( "status" , "A" )).projection(include( "item" , "status" , "instock.qty" )) Project Specific Array Elements in the Returned Array MongoDB Shell Compass C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Node.js Perl PHP Python Ruby Scala For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "instock.0": 1 } projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For example, the following operation will not project the array
with the first element: Builders<BsonDocument>.Projection.Include("instock.0") For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. include("instock.0") projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. include("instock.0") projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. include("instock.0") projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. include("instock.0") projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "instock.0": 1 } projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "instock.0" => 1 } projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. [ "instock.0" => 1 ] projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "instock.0": 1 } projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "instock.0" => 1 } projection does not project the array
with the first element. For fields that contain arrays, MongoDB provides the following
projection operators for manipulating arrays: $elemMatch , $slice , and $ . The following example uses the $slice projection operator
to return the last element in the instock array: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { status : "A" } , { item : 1 , status : 1 , instock : { $slice : - 1 } } ) Copy the following expression into the Filter field: { status : "A" } Click Options to open the additional query
options. Copy the following expression into the Project field: { item : 1 , status : 1 , instock : { $slice : - 1 } } Click Find . mongoc_collection_t *collection; bson_t *filter; bson_t *opts; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "status" , BCON_UTF8 ( "A" ) ) ; opts = BCON_NEW ( "projection" , "{" , "item" , BCON_INT64 ( 1 ) , "status" , BCON_INT64 ( 1 ) , "instock" , "{" , "$slice" , BCON_INT64 ( -1 ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, opts, NULL ) ; var filter = Builders<BsonDocument>.Filter.Eq( "status" , "A" ); var projection = Builders<BsonDocument>.Projection.Include( "item" ).Include( "status" ).Slice( "instock" , -1 ); var result = collection.Find<BsonDocument>(filter).Project(projection).ToList(); projection := bson.D{ { "item" , 1 }, { "status" , 1 }, { "instock" , bson.D{ { "$slice" , -1 }, }}, } cursor, err := coll.Find( context.TODO(), bson.D{ { "status" , "A" }, }, options.Find().SetProjection(projection), ) findPublisher = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the com.mongodb.client.FindIterable.projection method to the find method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. findIterable = collection.find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))); To specify a projection document, chain the FindFlow.projection() method to the find() method. The example uses the com.mongodb.client.model.Projections class to create the
projection documents. val findFlow = collection .find(eq( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , - 1 ))) cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) const cursor = db . collection ( 'inventory' ) . find ( { status : 'A' }) . project ( { item : 1 , status : 1 , instock : { $slice : - 1 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { status => "A" } , { projection => { item => 1 , status => 1 , instock => { '$slice' = > - 1 } } } ) ; $cursor = $db ->inventory-> find ( [ 'status' => 'A' ], [ 'projection' => [ 'item' => 1 , 'status' => 1 , 'instock' => [ '$slice' => - 1 ]]], ) ; cursor = db.inventory.find( { "status" : "A" }, { "item" : 1 , "status" : 1 , "instock" : { "$slice" : - 1 }} ) client [ : inventory ].find ( { status: 'A' } , projection: { 'item' = > 1 , 'status' = > 1 , 'instock' = > { '$slice' = > - 1 } }) findObservable = collection.find(equal( "status" , "A" )) .projection(fields(include( "item" , "status" ), slice( "instock" , -1 ))) $elemMatch , $slice , and $ are the only operators that you can use to project specific elements
to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. include("instock.0") projection does not project the array
with the first element. Project Fields with Aggregation Expressions You can specify aggregation expressions in a query projection. Aggregation expressions let you project new
fields and modify the values of existing fields. For example, the following operation uses aggregation expressions to
override the value of the status field, and project new fields area and reportNumber . Note The following example uses MongoDB Shell syntax. For driver examples
of projection with aggregation, see your driver
documentation . db. inventory . find ( { } , { _id : 0 , item : 1 , status : { $switch : { branches : [ { case : { $eq : [ "$status" , "A" ] } , then : "Available" } , { case : { $eq : [ "$status" , "D" ] } , then : "Discontinued" } , ] , default : "No status found" } } , area : { $concat : [ { $toString : { $multiply : [ "$size.h" , "$size.w" ] } } , " " , "$size.uom" ] } , reportNumber : { $literal : 1 } } ) HIDE OUTPUT [ { item : 'journal' , status : 'Available' , area : '294 cm' , reportNumber : 1 } , { item : 'planner' , status : 'Discontinued' , area : '685.5 cm' , reportNumber : 1 } , { item : 'notebook' , status : 'Available' , area : '93.5 in' , reportNumber : 1 } , { item : 'paper' , status : 'Discontinued' , area : '93.5 in' , reportNumber : 1 } , { item : 'postcard' , status : 'Available' , area : '152.5 cm' , reportNumber : 1 } ] Project Fields to Return from a Query with MongoDB Atlas The example in this section uses the sample movies dataset . To learn how to load the sample dataset
into your MongoDB Atlas deployment, see Load Sample Data . To project fields to return from a query in MongoDB Atlas, follow these
steps: 1 In the MongoDB Atlas UI, go to the Clusters page for your project. If it's not already displayed, select the organization that
contains your desired project from the Organizations menu in the
navigation bar. If it's not already displayed, select your project
from the Projects menu in the navigation bar. If it's not already displayed, click Clusters in the
sidebar. The Clusters page displays. 2 Navigate to the collection For the cluster that contains the sample data,
click Browse Collections . In the left navigation pane, select the sample_mflix database. Select the movies collection. 3 Specify the Filter field Click More Options on the right side of the Filter field. Specify the query filter. Specify the query filter document in the Filter field. A query filter document uses query operators to specify
search conditions. Copy the following query filter document into the Filter search bar: { year : 1924 } 4 Specify the fields to project Specify the field(s) to return in the query results. Copy the following project document into the Project bar: { title : 1 , plot : 1 } 5 Click Apply This query filter returns the following fields for all documents
in the sample_mflix.movies collection where the year field matches 1924 : _id title plot MongoDB Atlas returns the _id field by default. To omit the _id field, copy the following project document
into the Project bar and click Apply : { title : 1 , plot : 1 , _id : 0 } Additional Considerations MongoDB enforces additional restrictions with regards to projections.
See Projection Restrictions for details. Tip See also: Projection Query Documents Back Arrays of Embedded Documents Next Null or Missing Fields
