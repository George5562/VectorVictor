# Query an Array of Embedded Documents - MongoDB Manual v8.0


Docs Home / MongoDB Manual / CRUD Operations / Query Query an Array of Embedded Documents On this page Query for a Document Nested in an Array Specify a Query Condition on a Field in an Array of Documents Specify Multiple Conditions for Array of Documents Query an Array of Documents with MongoDB Atlas Additional Query Tutorials You can query documents in MongoDB by using the following
methods: Your programming language's driver. The MongoDB Atlas UI . To learn more, see Query an Array of Documents with MongoDB Atlas . MongoDB Compass . â¤ Use the Select your language drop-down menu in the
upper-right to set the language of the following examples or select
MongoDB Compass. MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala This page provides examples of query operations on an array of nested documents using the db.collection.find() method in mongosh . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using MongoDB Compass . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using mongoc_collection_find_with_opts . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the MongoCollection.Find() method in the MongoDB C# Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the Collection.Find function in the MongoDB Go Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the com.mongodb.reactivestreams.client.MongoCollection.find method in the MongoDB Java Reactive Streams Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the com.mongodb.client.MongoCollection.find method in the MongoDB Java Synchronous Driver . Tip The driver provides com.mongodb.client.model.Filters helper methods to facilitate the creation of filter
documents. The examples on this page use these methods to
create the filter documents. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents by using the MongoCollection.find() method in the MongoDB Kotlin Coroutine Driver . Tip The driver provides com.mongodb.client.model.Filters helper methods to facilitate the creation of filter
documents. The examples on this page use these methods to
create the filter documents. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the motor.motor_asyncio.AsyncIOMotorCollection.find method in the Motor driver. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the Collection.find() method in
the MongoDB Node.js Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the MongoDB::Collection::find() method
in the MongoDB Perl Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the MongoDB\\Collection::find() method in the MongoDB PHP Library . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the pymongo.collection.Collection.find method in the PyMongo Python driver. The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the Mongo::Collection#find() method in the MongoDB Ruby Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: This page provides examples of query operations on an array of nested documents using the collection.find() method
in the MongoDB Scala Driver . The examples on this page use the inventory collection. Connect to a
test database in your MongoDB instance then create the inventory collection: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . insertMany ( [ { item : "journal" , instock : [ { warehouse : "A" , qty : 5 } , { warehouse : "C" , qty : 15 } ] } , { item : "notebook" , instock : [ { warehouse : "C" , qty : 5 } ] } , { item : "paper" , instock : [ { warehouse : "A" , qty : 60 } , { warehouse : "B" , qty : 15 } ] } , { item : "planner" , instock : [ { warehouse : "A" , qty : 40 } , { warehouse : "B" , qty : 5 } ] } , { item : "postcard" , instock : [ { warehouse : "B" , qty : 15 } , { warehouse : "C" , qty : 35 } ] } ]) ; [ { "item" : "journal" , "instock" : [ { "warehouse" : "A" , "qty" : 5 } , { "warehouse" : "C" , "qty" : 15 } ] } , { "item" : "notebook" , "instock" : [ { "warehouse" : "C" , "qty" : 5 } ] } , { "item" : "paper" , "instock" : [ { "warehouse" : "A" , "qty" : 60 } , { "warehouse" : "B" , "qty" : 15 } ] } , { "item" : "planner" , "instock" : [ { "warehouse" : "A" , "qty" : 40 } , { "warehouse" : "B" , "qty" : 5 } ] } , { "item" : "postcard" , "instock" : [ { "warehouse" : "B" , "qty" : 15 } , { "warehouse" : "C" , "qty" : 35 } ] } ] For instructions on inserting documents in MongoDB Compass, see Insert Documents . mongoc_collection_t *collection; mongoc_bulk_operation_t *bulk; bson_t *doc; bool r; bson_error_t error; bson_t reply; collection = mongoc_database_get_collection (db, "inventory" ) ; bulk = mongoc_collection_create_bulk_operation_with_opts (collection, NULL ) ; doc = BCON_NEW ( "item" , BCON_UTF8 ( "journal" ) , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 5 ) , "}" , "{" , "warehouse" , BCON_UTF8 ( "C" ) , "qty" , BCON_INT64 ( 15 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "notebook" ) , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "C" ) , "qty" , BCON_INT64 ( 5 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "paper" ) , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 60 ) , "}" , "{" , "warehouse" , BCON_UTF8 ( "B" ) , "qty" , BCON_INT64 ( 15 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "planner" ) , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 40 ) , "}" , "{" , "warehouse" , BCON_UTF8 ( "B" ) , "qty" , BCON_INT64 ( 5 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } doc = BCON_NEW ( "item" , BCON_UTF8 ( "postcard" ) , "instock" , "[" , "{" , "warehouse" , BCON_UTF8 ( "B" ) , "qty" , BCON_INT64 ( 15 ) , "}" , "{" , "warehouse" , BCON_UTF8 ( "C" ) , "qty" , BCON_INT64 ( 35 ) , "}" , "]" ) ; r = mongoc_bulk_operation_insert_with_opts (bulk, doc, NULL , &error) ; bson_destroy (doc) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; goto done; } /* "reply" is initialized on success or error */ r = ( bool ) mongoc_bulk_operation_execute (bulk, &reply, &error) ; if (!r) { MONGOC_ERROR ( "%s \n " , error.message) ; } var documents = new [] { new BsonDocument { { "item" , "journal" }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 5 } }, new BsonDocument { { "warehouse" , "C" }, { "qty" , 15 } } } } }, new BsonDocument { { "item" , "notebook" }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "C" }, { "qty" , 5 } } } } }, new BsonDocument { { "item" , "paper" }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 60 } }, new BsonDocument { { "warehouse" , "B" }, { "qty" , 15 } } } } }, new BsonDocument { { "item" , "planner" }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "A" }, { "qty" , 40 } }, new BsonDocument { { "warehouse" , "B" }, { "qty" , 5 } } } } }, new BsonDocument { { "item" , "postcard" }, { "instock" , new BsonArray { new BsonDocument { { "warehouse" , "B" }, { "qty" , 15 } }, new BsonDocument { { "warehouse" , "C" }, { "qty" , 35 } } } } } }; collection.InsertMany(documents); docs := [] interface {}{ bson.D{ { "item" , "journal" }, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 5 }, }, bson.D{ { "warehouse" , "C" }, { "qty" , 15 }, }, }}, }, bson.D{ { "item" , "notebook" }, { "instock" , bson.A{ bson.D{ { "warehouse" , "C" }, { "qty" , 5 }, }, }}, }, bson.D{ { "item" , "paper" }, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 60 }, }, bson.D{ { "warehouse" , "B" }, { "qty" , 15 }, }, }}, }, bson.D{ { "item" , "planner" }, { "instock" , bson.A{ bson.D{ { "warehouse" , "A" }, { "qty" , 40 }, }, bson.D{ { "warehouse" , "B" }, { "qty" , 5 }, }, }}, }, bson.D{ { "item" , "postcard" }, { "instock" , bson.A{ bson.D{ { "warehouse" , "B" }, { "qty" , 15 }, }, bson.D{ { "warehouse" , "C" }, { "qty" , 35 }, }, }}, }, } result, err := coll.InsertMany(context.TODO(), docs) Publisher<Success> insertManyPublisher = collection.insertMany(asList( Document.parse( "{ item: 'journal', instock: [ { warehouse: 'A', qty: 5 }, { warehouse: 'C', qty: 15 } ] }" ), Document.parse( "{ item: 'notebook', instock: [ { warehouse: 'C', qty: 5 } ] }" ), Document.parse( "{ item: 'paper', instock: [ { warehouse: 'A', qty: 60 }, { warehouse: 'B', qty: 15 } ] }" ), Document.parse( "{ item: 'planner', instock: [ { warehouse: 'A', qty: 40 }, { warehouse: 'B', qty: 5 } ] }" ), Document.parse( "{ item: 'postcard', instock: [ { warehouse: 'B', qty: 15 }, { warehouse: 'C', qty: 35 } ] }" ) )); collection.insertMany(asList( Document.parse( "{ item: 'journal', instock: [ { warehouse: 'A', qty: 5 }, { warehouse: 'C', qty: 15 } ] }" ), Document.parse( "{ item: 'notebook', instock: [ { warehouse: 'C', qty: 5 } ] }" ), Document.parse( "{ item: 'paper', instock: [ { warehouse: 'A', qty: 60 }, { warehouse: 'B', qty: 15 } ] }" ), Document.parse( "{ item: 'planner', instock: [ { warehouse: 'A', qty: 40 }, { warehouse: 'B', qty: 5 } ] }" ), Document.parse( "{ item: 'postcard', instock: [ { warehouse: 'B', qty: 15 }, { warehouse: 'C', qty: 35 } ] }" ) )); collection.insertMany( listOf( Document( "item" , "journal" ) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 5 ), Document( "warehouse" , "C" ).append( "qty" , 15 ) )), Document( "item" , "notebook" ) .append( "instock" , listOf( Document( "warehouse" , "C" ).append( "qty" , 5 ) )), Document( "item" , "paper" ) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 60 ), Document( "warehouse" , "B" ).append( "qty" , 15 ) )), Document( "item" , "planner" ) .append( "instock" , listOf( Document( "warehouse" , "A" ).append( "qty" , 40 ), Document( "warehouse" , "B" ).append( "qty" , 5 ) )), Document( "item" , "postcard" ) .append( "instock" , listOf( Document( "warehouse" , "B" ).append( "qty" , 15 ), Document( "warehouse" , "C" ).append( "qty" , 35 ) )), ) ) # Subdocument key order matters in a few of these examples so we have # to use bson.son.SON instead of a Python dict. from bson.son import SON await db.inventory.insert_many( [ { "item" : "journal" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 5 )]), SON([( "warehouse" , "C" ), ( "qty" , 15 )]), ], }, { "item" : "notebook" , "instock" : [SON([( "warehouse" , "C" ), ( "qty" , 5 )])]}, { "item" : "paper" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 60 )]), SON([( "warehouse" , "B" ), ( "qty" , 15 )]), ], }, { "item" : "planner" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 40 )]), SON([( "warehouse" , "B" ), ( "qty" , 5 )]), ], }, { "item" : "postcard" , "instock" : [ SON([( "warehouse" , "B" ), ( "qty" , 15 )]), SON([( "warehouse" , "C" ), ( "qty" , 35 )]), ], }, ] ) await db. collection ( 'inventory' ). insertMany ( [ { item : 'journal' , instock : [ { warehouse : 'A' , qty : 5 } , { warehouse : 'C' , qty : 15 } ] } , { item : 'notebook' , instock : [ { warehouse : 'C' , qty : 5 }] } , { item : 'paper' , instock : [ { warehouse : 'A' , qty : 60 } , { warehouse : 'B' , qty : 15 } ] } , { item : 'planner' , instock : [ { warehouse : 'A' , qty : 40 } , { warehouse : 'B' , qty : 5 } ] } , { item : 'postcard' , instock : [ { warehouse : 'B' , qty : 15 } , { warehouse : 'C' , qty : 35 } ] } ]) ; # Subdocument key order matters in this example so we have # to use Tie::IxHash instead of a regular, unordered Perl hash. $db - > coll ( "inventory" ) - > insert_many ( [ { item    => "journal" , instock => [ Tie : : IxHash - > new ( warehouse => "A" , qty => 5 ) , Tie : : IxHash - > new ( warehouse => "C" , qty => 15 ) ] } , { item    => "notebook" , instock => [ Tie : : IxHash - > new ( warehouse => "C" , qty => 5 ) ] } , { item    => "paper" , instock => [ Tie : : IxHash - > new ( warehouse => "A" , qty => 60 ) , Tie : : IxHash - > new ( warehouse => "B" , qty => 15 ) ] } , { item    => "planner" , instock => [ Tie : : IxHash - > new ( warehouse => "A" , qty => 40 ) , Tie : : IxHash - > new ( warehouse => "B" , qty => 5 ) ] } , { item    => "postcard" , instock => [ Tie : : IxHash - > new ( warehouse => "B" , qty => 15 ) , Tie : : IxHash - > new ( warehouse => "C" , qty => 35 ) ] } ] ) ; $insertManyResult = $db ->inventory-> insertMany ([ [ 'item' => 'journal' , 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 5 ], [ 'warehouse' => 'C' , 'qty' => 15 ], ], ], [ 'item' => 'notebook' , 'instock' => [ [ 'warehouse' => 'C' , 'qty' => 5 ], ], ], [ 'item' => 'paper' , 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 60 ], [ 'warehouse' => 'B' , 'qty' => 15 ], ], ], [ 'item' => 'planner' , 'instock' => [ [ 'warehouse' => 'A' , 'qty' => 40 ], [ 'warehouse' => 'B' , 'qty' => 5 ], ], ], [ 'item' => 'postcard' , 'instock' => [ [ 'warehouse' => 'B' , 'qty' => 15 ], [ 'warehouse' => 'C' , 'qty' => 35 ], ], ], ]) ; # Subdocument key order matters in a few of these examples so we have # to use bson.son.SON instead of a Python dict. from bson.son import SON db.inventory.insert_many( [ { "item" : "journal" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 5 )]), SON([( "warehouse" , "C" ), ( "qty" , 15 )]), ], }, { "item" : "notebook" , "instock" : [SON([( "warehouse" , "C" ), ( "qty" , 5 )])]}, { "item" : "paper" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 60 )]), SON([( "warehouse" , "B" ), ( "qty" , 15 )]), ], }, { "item" : "planner" , "instock" : [ SON([( "warehouse" , "A" ), ( "qty" , 40 )]), SON([( "warehouse" , "B" ), ( "qty" , 5 )]), ], }, { "item" : "postcard" , "instock" : [ SON([( "warehouse" , "B" ), ( "qty" , 15 )]), SON([( "warehouse" , "C" ), ( "qty" , 35 )]), ], }, ] ) client [ : inventory ].insert_many ( [ { item: 'journal' , instock: [ { warehouse: 'A' , qty: 5 } , { warehouse: 'C' , qty: 15 }] } , { item: 'notebook' , instock: [ { warehouse: 'C' , qty: 5 }] } , { item: 'paper' , instock: [ { warehouse: 'A' , qty: 60 } , { warehouse: 'B' , qty: 15 }] } , { item: 'planner' , instock: [ { warehouse: 'A' , qty: 40 } , { warehouse: 'B' , qty: 5 }] } , { item: 'postcard' , instock: [ { warehouse: 'B' , qty: 15 } , { warehouse: 'C' , qty: 35 }] } ]) collection.insertMany( Seq ( Document ( """{ item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] }""" ), Document ( """{ item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] }""" ), Document ( """{ item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] }""" ), Document ( """{ item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] }""" ), Document ( """{ item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }""" ) )).execute() Query for a Document Nested in an Array The following example selects all documents where an element in the instock array matches the specified document: MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock" : { warehouse : "A" , qty : 5 } } ) Copy the following filter into the Compass query bar and click Find : { "instock" : { warehouse : "A" , qty : 5 } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock" , "{" , "warehouse" , BCON_UTF8 ( "A" ) , "qty" , BCON_INT64 ( 5 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.AnyEq( "instock" , new BsonDocument { { "warehouse" , "A" }, { "qty" , 5 } }); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock" , bson.D{ { "warehouse" , "A" }, { "qty" , 5 }, }}, }) FindPublisher<Document> findPublisher = collection.find(eq( "instock" , Document.parse( "{ warehouse: 'A', qty: 5 }" ))); FindIterable<Document> findIterable = collection.find(eq( "instock" , Document.parse( "{ warehouse: 'A', qty: 5 }" ))); val findFlow = collection .find(eq( "instock" , Document.parse( "{ warehouse: 'A', qty: 5 }" ))) cursor = db.inventory.find({ "instock" : SON([( "warehouse" , "A" ), ( "qty" , 5 )])}) const cursor = db. collection ( 'inventory' ). find ( { instock : { warehouse : 'A' , qty : 5 } }) ; # Subdocument key order matters in this example so we have # to use Tie::IxHash instead of a regular, unordered Perl hash. $cursor = $db - > coll ( "inventory" ) - > find ( { instock => Tie : : IxHash - > new ( warehouse => "A" , qty => 5 ) } ) ; $cursor = $db ->inventory-> find ([ 'instock' => [ 'warehouse' => 'A' , 'qty' => 5 ]]) ; cursor = db.inventory.find({ "instock" : SON([( "warehouse" , "A" ), ( "qty" , 5 )])}) client [ : inventory ].find ( instock: { warehouse: 'A' , qty: 5 }) var findObservable = collection.find(equal( "instock" , Document ( "warehouse" -> "A" , "qty" -> 5 ))) Equality matches on the whole embedded/nested document require an exact match of the specified document, including the field order. For
example, the following query does not match any documents in the inventory collection: MongoDB Shell C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock" : { qty : 5 , warehouse : "A" } } ) mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock" , "{" , "qty" , BCON_INT64 ( 5 ) , "warehouse" , BCON_UTF8 ( "A" ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.AnyEq( "instock" , new BsonDocument { { "qty" , 5 }, { "warehouse" , "A" } }); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock" , bson.D{ { "qty" , 5 }, { "warehouse" , "A" }, }}, }) findPublisher = collection.find(eq( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))); findIterable = collection.find(eq( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))); val findFlow = collection .find(eq( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))) cursor = db.inventory.find({ "instock" : SON([( "qty" , 5 ), ( "warehouse" , "A" )])}) const cursor = db. collection ( 'inventory' ). find ( { instock : { qty : 5 , warehouse : 'A' } }) ; # Subdocument key order matters in this example so we have # to use Tie::IxHash instead of a regular, unordered Perl hash. $cursor = $db - > coll ( "inventory" ) - > find ( { instock => Tie : : IxHash - > new ( qty => 5 , warehouse => "A" ) } ) ; $cursor = $db ->inventory-> find ([ 'instock' => [ 'qty' => 5 , 'warehouse' => 'A' ]]) ; cursor = db.inventory.find({ "instock" : SON([( "qty" , 5 ), ( "warehouse" , "A" )])}) client [ : inventory ].find ( instock: { qty: 5 , warehouse: 'A' } ) findObservable = collection.find(equal( "instock" , Document ( "qty" -> 5 , "warehouse" -> "A" ))) Specify a Query Condition on a Field in an Array of Documents Specify a Query Condition on a Field Embedded in an Array of Documents If you do not know the index position of the document nested in the
array, concatenate the name of the array field, with a dot ( . ) and
the name of the field in the nested document. The following example selects all documents where the instock array
has at least one embedded document that contains the field qty whose value is less than or equal to 20 : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { 'instock.qty' : { $lte : 20 } } ) Copy the following filter into the Compass query bar and click Find : { 'instock.qty' : { $lte : 20 } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock.qty" , "{" , "$lte" , BCON_INT64 ( 20 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.Lte( "instock.qty" , 20 ); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock.qty" , bson.D{ { "$lte" , 20 }, }}, }) findPublisher = collection.find(lte( "instock.qty" , 20 )); findIterable = collection.find(lte( "instock.qty" , 20 )); val findFlow = collection .find(lte( "instock.qty" , 20 )) cursor = db.inventory.find({ "instock.qty" : { "$lte" : 20 }}) const cursor = db. collection ( 'inventory' ). find ( { 'instock.qty' : { $lte : 20 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { 'instock.qty' = > { '$lte' = > 20 } } ) ; $cursor = $db ->inventory-> find ([ 'instock.qty' => [ '$lte' => 20 ]]) ; cursor = db.inventory.find({ "instock.qty" : { "$lte" : 20 }}) client [ : inventory ].find ( 'instock.qty' = > { '$lte' = > 20 }) findObservable = collection.find(lte( "instock.qty" , 20 )) Use the Array Index to Query for a Field in the Embedded Document Using dot notation , you can specify query conditions for
field in a document at a particular index or position of the array. The
array uses zero-based indexing. Note When querying using dot notation, the field and index must be
inside quotation marks. The following example selects all documents where the instock array
has as its first element a document that contains the field qty whose value is less than or equal to 20 : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { 'instock.0.qty' : { $lte : 20 } } ) Copy the following filter into the Compass query bar and click Find : { 'instock.0.qty' : { $lte : 20 } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock.0.qty" , "{" , "$lte" , BCON_INT64 ( 20 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.Lte( "instock.0.qty" , 20 ); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock.0.qty" , bson.D{ { "$lte" , 20 }, }}, }) findPublisher = collection.find(lte( "instock.0.qty" , 20 )); findIterable = collection.find(lte( "instock.0.qty" , 20 )); val findFlow = collection .find(lte( "instock.0.qty" , 20 )) cursor = db.inventory.find({ "instock.0.qty" : { "$lte" : 20 }}) const cursor = db. collection ( 'inventory' ). find ( { 'instock.0.qty' : { $lte : 20 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { 'instock.0.qty' = > { '$lte' = > 20 } } ) ; $cursor = $db ->inventory-> find ([ 'instock.0.qty' => [ '$lte' => 20 ]]) ; cursor = db.inventory.find({ "instock.0.qty" : { "$lte" : 20 }}) client [ : inventory ].find ( 'instock.0.qty' = > { '$lte' = > 20 }) findObservable = collection.find(lte( "instock.0.qty" , 20 )) Specify Multiple Conditions for Array of Documents When specifying conditions on more than one field nested in an array of
documents, you can specify the query such that either a single document
meets these condition or any combination of documents (including a
single document) in the array meets the conditions. A Single Nested Document Meets Multiple Query Conditions on Nested Fields Use $elemMatch operator to specify multiple criteria on an
array of embedded documents such that at least one embedded document
satisfies all the specified criteria. The following example queries for documents where the instock array
has at least one embedded document that contains both the field qty equal to 5 and the field warehouse equal
to A : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock" : { $elemMatch : { qty : 5 , warehouse : "A" } } } ) Copy the following filter into the Compass query bar and click Find : { "instock" : { $elemMatch : { qty : 5 , warehouse : "A" } } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock" , "{" , "$elemMatch" , "{" , "qty" , BCON_INT64 ( 5 ) , "warehouse" , BCON_UTF8 ( "A" ) , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.ElemMatch<BsonValue>( "instock" , new BsonDocument { { "qty" , 5 }, { "warehouse" , "A" } }); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock" , bson.D{ { "$elemMatch" , bson.D{ { "qty" , 5 }, { "warehouse" , "A" }, }}, }}, }) findPublisher = collection.find(elemMatch( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))); findIterable = collection.find(elemMatch( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))); val findFlow = collection .find(elemMatch( "instock" , Document.parse( "{ qty: 5, warehouse: 'A' }" ))) cursor = db.inventory.find({ "instock" : { "$elemMatch" : { "qty" : 5 , "warehouse" : "A" }}}) const cursor = db. collection ( 'inventory' ). find ( { instock : { $elemMatch : { qty : 5 , warehouse : 'A' } } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { instock => { '$elemMatch' = > { qty => 5 , warehouse => "A" } } } ) ; $cursor = $db ->inventory-> find ([ 'instock' => [ '$elemMatch' => [ 'qty' => 5 , 'warehouse' => 'A' ]]]) ; cursor = db.inventory.find({ "instock" : { "$elemMatch" : { "qty" : 5 , "warehouse" : "A" }}}) client [ : inventory ].find ( instock: { '$elemMatch' = > { qty: 5 , warehouse: 'A' } }) findObservable = collection.find(elemMatch( "instock" , Document ( "qty" -> 5 , "warehouse" -> "A" ))) The following example queries for documents where the instock array
has at least one embedded document that contains the field qty that
is greater than 10 and less than or equal to 20 : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock" : { $elemMatch : { qty : { $gt : 10 , $lte : 20 } } } } ) Copy the following filter into the Compass query bar and click Find : { "instock" : { $elemMatch : { qty : { $gt : 10 , $lte : 20 } } } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock" , "{" , "$elemMatch" , "{" , "qty" , "{" , "$gt" , BCON_INT64 ( 10 ) , "$lte" , BCON_INT64 ( 20 ) , "}" , "}" , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var filter = Builders<BsonDocument>.Filter.ElemMatch<BsonValue>( "instock" , new BsonDocument { { "qty" , new BsonDocument { { "$gt" , 10 }, { "$lte" , 20 } } } }); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock" , bson.D{ { "$elemMatch" , bson.D{ { "qty" , bson.D{ { "$gt" , 10 }, { "$lte" , 20 }, }}, }}, }}, }) findPublisher = collection.find(elemMatch( "instock" , Document.parse( "{ qty: { $gt: 10, $lte: 20 } }" ))); findIterable = collection.find(elemMatch( "instock" , Document.parse( "{ qty: { $gt: 10, $lte: 20 } }" ))); val findFlow = collection .find(elemMatch( "instock" , Document.parse( "{ qty: { \$ gt: 10, \$ lte: 20 } }" ))) cursor = db.inventory.find({ "instock" : { "$elemMatch" : { "qty" : { "$gt" : 10 , "$lte" : 20 }}}}) const cursor = db. collection ( 'inventory' ). find ( { instock : { $elemMatch : { qty : { $gt : 10 , $lte : 20 } } } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { instock => { '$elemMatch' = > { qty => { '$gt' = > 10 , '$lte' = > 20 } } } } ) ; $cursor = $db ->inventory-> find ([ 'instock' => [ '$elemMatch' => [ 'qty' => [ '$gt' => 10 , '$lte' => 20 ]]]]) ; cursor = db.inventory.find({ "instock" : { "$elemMatch" : { "qty" : { "$gt" : 10 , "$lte" : 20 }}}}) client [ : inventory ].find ( instock: { '$elemMatch' = > { qty: { '$gt' = > 10 , '$lte' = > 20 } } }) findObservable = collection.find(elemMatch( "instock" , Document ( """{ qty: { $gt: 10, $lte: 20 } }""" ))) Combination of Elements Satisfies the Criteria If the compound query conditions on an array field do not use the $elemMatch operator, the query selects those documents whose
array contains any combination of elements that satisfies the
conditions. For example, the following query matches documents where any document
nested in the instock array has the qty field greater than 10 and any document (but not necessarily the same embedded
document) in the array has the qty field less than or equal to 20 : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock.qty" : { $gt : 10 , $lte : 20 } } ) Copy the following filter into the Compass query bar and click Find : { "instock.qty" : { $gt : 10 , $lte : 20 } } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock.qty" , "{" , "$gt" , BCON_INT64 ( 10 ) , "$lte" , BCON_INT64 ( 20 ) , "}" ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var builder = Builders<BsonDocument>.Filter; var filter = builder.And(builder.Gt( "instock.qty" , 10 ), builder.Lte( "instock.qty" , 20 )); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock.qty" , bson.D{ { "$gt" , 10 }, { "$lte" , 20 }, }}, }) findPublisher = collection.find(and(gt( "instock.qty" , 10 ), lte( "instock.qty" , 20 ))); findIterable = collection.find(and(gt( "instock.qty" , 10 ), lte( "instock.qty" , 20 ))); val findFlow = collection .find(and(gt( "instock.qty" , 10 ), lte( "instock.qty" , 20 ))) cursor = db.inventory.find({ "instock.qty" : { "$gt" : 10 , "$lte" : 20 }}) const cursor = db. collection ( 'inventory' ). find ( { 'instock.qty' : { $gt : 10 , $lte : 20 } }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { "instock.qty" = > { '$gt' = > 10 , '$lte' = > 20 } } ) ; $cursor = $db ->inventory-> find ([ 'instock.qty' => [ '$gt' => 10 , '$lte' => 20 ]]) ; cursor = db.inventory.find({ "instock.qty" : { "$gt" : 10 , "$lte" : 20 }}) client [ : inventory ].find ( 'instock.qty' = > { '$gt' = > 10 , '$lte' = > 20 }) findObservable = collection.find(and(gt( "instock.qty" , 10 ), lte( "instock.qty" , 20 ))) The following example queries for documents where the instock array
has at least one embedded document that contains the field qty equal to 5 and at least one embedded document (but not necessarily
the same embedded document) that contains the field warehouse equal
to A : MongoDB Shell Compass C C# Go Java (Async) Java (Sync) Kotlin (Coroutine) Motor Node.js Perl PHP Python Ruby Scala db. inventory . find ( { "instock.qty" : 5 , "instock.warehouse" : "A" } ) Copy the following filter into the Compass query bar and click Find : { "instock.qty" : 5 , "instock.warehouse" : "A" } mongoc_collection_t *collection; bson_t *filter; mongoc_cursor_t *cursor; collection = mongoc_database_get_collection (db, "inventory" ) ; filter = BCON_NEW ( "instock.qty" , BCON_INT64 ( 5 ) , "instock.warehouse" , BCON_UTF8 ( "A" ) ) ; cursor = mongoc_collection_find_with_opts (collection, filter, NULL , NULL ) ; var builder = Builders<BsonDocument>.Filter; var filter = builder.And(builder.Eq( "instock.qty" , 5 ), builder.Eq( "instock.warehouse" , "A" )); var result = collection.Find(filter).ToList(); cursor, err := coll.Find( context.TODO(), bson.D{ { "instock.qty" , 5 }, { "instock.warehouse" , "A" }, }) findPublisher = collection.find(and(eq( "instock.qty" , 5 ), eq( "instock.warehouse" , "A" ))); findIterable = collection.find(and(eq( "instock.qty" , 5 ), eq( "instock.warehouse" , "A" ))); val findFlow = collection .find(and(eq( "instock.qty" , 5 ), eq( "instock.warehouse" , "A" ))) cursor = db.inventory.find({ "instock.qty" : 5 , "instock.warehouse" : "A" }) const cursor = db. collection ( 'inventory' ). find ( { 'instock.qty' : 5 , 'instock.warehouse' : 'A' }) ; $cursor = $db - > coll ( "inventory" ) - > find ( { "instock.qty" = > 5 , "instock.warehouse" = > "A" } ) ; $cursor = $db ->inventory-> find ([ 'instock.qty' => 5 , 'instock.warehouse' => 'A' ]) ; cursor = db.inventory.find({ "instock.qty" : 5 , "instock.warehouse" : "A" }) client [ : inventory ].find ( 'instock.qty' = > 5 , 'instock.warehouse' = > 'A' ) findObservable = collection.find(and(equal( "instock.qty" , 5 ), equal( "instock.warehouse" , "A" ))) Query an Array of Documents with MongoDB Atlas The example in this section uses the sample training dataset . To learn how to load the sample
dataset into your MongoDB Atlas deployment, see Load Sample Data . To query an array of documents in MongoDB Atlas, follow these steps: 1 In the MongoDB Atlas UI, go to the Clusters page for your project. If it's not already displayed, select the organization that
contains your desired project from the Organizations menu in the
navigation bar. If it's not already displayed, select your project
from the Projects menu in the navigation bar. If it's not already displayed, click Clusters in the
sidebar. The Clusters page displays. 2 Navigate to the collection For the cluster that contains the sample data,
click Browse Collections . In the left navigation pane, select the sample_training database. Select the grades collection. 3 Specify the Filter field Specify the query filter document in the Filter field. A query filter document uses query operators to specify
search conditions. Copy the following query filter document into the Filter search bar: { "scores.type" : "exam" } 4 Click Apply This query filter returns all documents in the sample_training.grades collection that contain a subdocument in the scores array where type is set to exam . The full document, including the entire scores array, is returned. For more information on modifying the
returned array, see Project Specific Array Elements in the Returned Array . Additional Query Tutorials For additional query examples, see: Query an Array Query Documents Query on Embedded/Nested Documents Back Arrays Next Project Results
