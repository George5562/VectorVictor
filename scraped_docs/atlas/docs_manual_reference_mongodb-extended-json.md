# MongoDB Extended JSON (v2) - MongoDB Manual v8.0


Docs Home / MongoDB Manual / Introduction / BSON Types MongoDB Extended JSON (v2) On this page MongoDB Extended JSON v2 Usage BSON Data Types and Associated Representations Examples Important Disambiguation The following page discusses MongoDB Extended JSON v2. For
discussion on the Legacy MongoDB Extended JSON v1, see MongoDB Extended JSON (v1) . For supported data types in mongosh , see mongosh Data Types . JSON can only directly represent a subset of the types
supported by BSON . To preserve type information, MongoDB adds
the following extensions to the JSON format. Canonical Mode A string format that emphasizes type preservation at the expense
of readability and interoperability. That is, conversion from
canonical to BSON will generally preserve type information except
in certain specific cases. Relaxed Mode A string format that emphasizes readability and interoperability
at the expense of type preservation. That is, conversion from
relaxed format to BSON can lose type information. Both formats conform to the JSON RFC and can be
parsed by the various MongoDB drivers and tools. MongoDB Extended JSON v2 Usage Drivers The following drivers use the Extended JSON v2.0 C C++ Go Java Node Perl PHPC Python Scala For C# and Ruby that use Legacy MongoDB Extended JSON v1, refer to MongoDB Extended JSON (v1) . Extended JSON Methods MongoDB provides the following methods for Extended JSON: Method Description serialize Serializes a BSON object and returns the data in Extended JSON
format. EJSON . serialize ( db. < collection > . findOne ( ) ) deserialize Converts a serialized document to field and value pairs. The
values have BSON types . EJSON . deserialize ( < serialized object > ) stringify Converts the element and type pairs in a deserialized object to strings. EJSON . stringify ( < deserialized object > ) parse Converts strings into element and type pairs. EJSON . parse ( < string > ) For usage examples, see Extended JSON Object Conversions below. For additional details, see the documentation for: MongoDB NodeJS Driver BSON Parser BSON-EXT Parser MongoDB Database Tools Starting in version 4.2: Binary Changes bsondump Uses Extended JSON v2.0 (Canonical
mode) format. mongodump Use Extended JSON v2.0 (Canonical mode) format for the
metadata. Requires mongorestore version 4.2 or
later that supports Extended JSON v2.0 (Canonical mode or
Relaxed) format. In general, use corresponding versions of mongodump and mongorestore .
To restore data files created with a specific
version of mongodump , use the corresponding
version of mongorestore . mongoexport Creates output data in Extended JSON v2.0 (Relaxed mode) by
default. Creates output data in Extended JSON v2.0 (Canonical mode) if
used with --jsonFormat . mongoimport Expects import data to be in Extended JSON v2.0 (either
Relaxed or Canonical mode) by default. Can recognize data that is in Extended JSON v1.0 format if the option --legacy is specified. In general, the versions of mongoexport and mongoimport should match. To import
data created from mongoexport , you should use
the corresponding version of mongoimport . BSON Data Types and Associated Representations The following presents some common BSON data types and the associated
representations in Canonical and Relaxed . Array Binary Date Decimal128 Document Double Int32 Int64 MaxKey MinKey ObjectId Regular Expression Timestamp The complete list is here . Array Canonical Relaxed [ <elements> ] <Same as Canonical> Where the array elements are as follows: <elements> Array elements use Extended JSON. To specify an empty array, omit the content [ ] . Binary Canonical Relaxed { "$binary": { "base64": "<payload>", "subType": "<t>" } } <Same as Canonical> Where the values are as follows: "<payload>" Base64 encoded (with padding as "=") payload string. "<t>" A one- or two-character hex string that corresponds to a BSON binary
subtype. See the extended bson documentation http://bsonspec.org/spec.html for subtypes available. Date For dates between years 1970 and 9999, inclusive : Canonical Relaxed {"$date": {"$numberLong": "<millis>"}} {"$date": "<ISO-8601 Date/Time Format>"} For dates before year 1970 or after year 9999 : Canonical Relaxed {"$date": {"$numberLong": "<millis>"}} <Same as Canonical> Where the values are as follows: "<millis>" A 64-bit signed integer as string. The value represents milliseconds
relative to the epoch. "<ISO-8601 Date/Time Format>" A date in ISO-8601 Internet Date/Time Format as string. The date/time has a maximum time precision of milliseconds: Fractional seconds have exactly 3 decimal places if the fractional
part is non-zero. Otherwise, fractional seconds SHOULD be omitted if zero. Decimal128 Canonical Relaxed { "$numberDecimal": "<number>" } <Same as Canonical> Where the values are as follows: "<number>" A high-precision decimal as a string. Document Canonical Relaxed { <content> } <Same as Canonical> Where the document contents are as follows: <content> Name:value pairs that use Extended JSON. To specify an empty document, omit the content { } . Double For finite numbers : Canonical Relaxed {"$numberDouble": "<decimal string>" } <non-integer number> For infinite numbers or NAN : Canonical Relaxed {"$numberDouble": <"Infinity"|"-Infinity"|"NaN"> } <Same as Canonical> Where the values are as follows: "<decimal string>" A 64-bit signed floating point as a string. <non-integer number> A non-integer number. Integer numbers are parsed as an integer
instead of a double. Int64 Canonical Relaxed { "$numberLong": "<number>" } <integer> Where the values are as follows: "<number>" A 64-bit signed integer as string. <integer> A 64-bit signed integer. Int32 Canonical Relaxed { "$numberInt": "<number>" } <integer> Where the values are as follows: "<number>" A 32-bit signed integer as a string. <integer> A 32-bit signed integer. MaxKey Canonical Relaxed { "$maxKey": 1 } <Same as Canonical> The MaxKey BSON data type compares higher than all other types. See Comparison/Sort Order for more information on
comparison order for BSON types. MinKey Canonical Relaxed { "$minKey": 1 } <Same as Canonical> The MinKey BSON data type compares lower than all other types. See Comparison/Sort Order for more information on
comparison order for BSON types. ObjectId Canonical Relaxed { "$oid": "<ObjectId bytes>" } <Same as Canonical> Where the values are as follows: "<ObjectId bytes>" A 24-character, big-endian hexadecimal string that represents the
ObjectId bytes. Regular Expression Canonical Relaxed { "$regularExpression": { "pattern": "<regexPattern>", "options": "<options>" } } <Same as Canonical> Where the values are as follows: "<regexPattern>" A string that corresponds to the regular expression pattern. The
string can contain valid JSON characters and unescaped double quote
( " ) characters, but may not contain unescaped forward slash
( / ) characters. "<options>" A string that specifies BSON regular expression options. You must specify
the options in alphabetical order. For information on the supported options,
see $options . Timestamp Canonical Relaxed {"$timestamp": {"t": <t>, "i": <i>}} <Same as Canonical> Where the values are as follows: <t> A positive integer for the seconds since epoch. <i> A positive integer for the increment. Examples The following examples illustrate Extended JSON usage. Type Representations Example Field Name Canonical Format Relaxed Format "_id:" {"$oid":"5d505646cf6d4fe581014ab2"} {"$oid":"5d505646cf6d4fe581014ab2"} "arrayField": ["hello",{"$numberInt":"10"}] ["hello",10] "dateField": {"$date":{"$numberLong":"1565546054692"}} {"$date":"2019-08-11T17:54:14.692Z"} "dateBefore1970": {"$date":{"$numberLong":"-1577923200000"}} {"$date":{"$numberLong":"-1577923200000"}} "decimal128Field": {"$numberDecimal":"10.99"} {"$numberDecimal":"10.99"} "documentField": {"a":"hello"} {"a":"hello"} "doubleField": {"$numberDouble":"10.5"} 10.5 "infiniteNumber" {"$numberDouble":"Infinity"} {"$numberDouble":"Infinity"} "int32field": {"$numberInt":"10"} 10 "int64Field": {"$numberLong":"50"} 50 "minKeyField": {"$minKey":1} {"$minKey":1} "maxKeyField": {"$maxKey":1} {"$maxKey":1} "regexField": {"$regularExpression":{"pattern":"^H","options":"i"}} {"$regularExpression":{"pattern":"^H","options":"i"}} "timestampField": {"$timestamp":{"t":1565545664,"i":1}} {"$timestamp":{"t":1565545664,"i":1}} "uuid": {"$uuid":"3b241101-e2bb-4255-8caf-4136c566a962"} {"$uuid":"3b241101-e2bb-4255-8caf-4136c566a962"} Extended JSON Object Conversions The following short examples create a document object and then convert
the object to different forms using Extended JSON object conversion
methods. Setup Create a document in the conversions collection: db. conversions . insertOne ( { insertDate : new Date ( ) } ) mongosh returns a document object: { acknowledged : true , insertedId : ObjectId ( "61fbaf25671c45f3f5f4074a" ) } EJSON.serialize Serialize the data stored in a MongoDB document object: serialized = EJSON . serialize ( db. conversions . findOne ( ) ) mongosh parses a JavaScript object and returns values using "$" prefixed types : { _id : { '$oid' : '61fbaf25671c45f3f5f4074a' } , insertDate : { '$date' : '2022-02-03T10:32:05.230Z' } } EJSON.deserialize Deserialize a serialized object: EJSON . deserialize ( serialized ) mongosh parses a JavaScript object and returns values using
the default mongosh type form: { _id : new ObjectId ( "61fbaf25671c45f3f5f4074a" ) , insertDate : ISODate ( "2022-02-03T10:32:05.230Z" ) } EJSON.stringify Convert an object to a string: stringified = EJSON . stringify ( db. conversions . findOne ( ) ) mongosh outputs the elements of the converted object as
strings: { "_id" : { "$oid" : "61fbaf25671c45f3f5f4074a" } , "insertDate" : { "$date" : "2022-02-03T10:32:05.230Z" } } EJSON.parse Parse a string to create an object: EJSON . parse ( stringified ) mongosh returns the converted strings as documents: { _id : new ObjectId ( "61fbaf25671c45f3f5f4074a" ) , insertDate : ISODate ( "2022-02-03T10:32:05.230Z" ) } Back Migrate Undefined Data and Queries Next Extended JSON (v1)
